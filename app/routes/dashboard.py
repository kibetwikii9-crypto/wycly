"""Dashboard API routes for analytics and data retrieval."""
import logging
from datetime import datetime, timedelta
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy import func, and_
from sqlalchemy.orm import Session

from app.database import get_db
from app.models import Conversation, Lead, AnalyticsEvent, ChannelIntegration, User as UserModel
from app.routes.auth import get_current_user

log = logging.getLogger(__name__)
router = APIRouter(prefix="/api/dashboard", tags=["dashboard"])


@router.get("/overview")
async def get_overview(
    days: int = Query(7, ge=1, le=365),
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Get dashboard overview statistics with extended insights."""
    start_date = datetime.utcnow() - timedelta(days=days)
    last_24h = datetime.utcnow() - timedelta(hours=24)

    # Total conversations
    total_conversations = db.query(func.count(Conversation.id)).filter(
        Conversation.created_at >= start_date
    ).scalar() or 0

    # Active chats (conversations in last 24 hours)
    active_chats = db.query(func.count(Conversation.id)).filter(
        Conversation.created_at >= last_24h
    ).scalar() or 0

    # Leads captured
    total_leads = db.query(func.count(Lead.id)).filter(
        Lead.created_at >= start_date
    ).scalar() or 0

    # Most common intents
    intent_counts = (
        db.query(Conversation.intent, func.count(Conversation.id).label("count"))
        .filter(Conversation.created_at >= start_date)
        .group_by(Conversation.intent)
        .order_by(func.count(Conversation.id).desc())
        .limit(5)
        .all()
    )
    most_common_intents = [{"intent": intent, "count": count} for intent, count in intent_counts]

    # Channel distribution
    channel_counts = (
        db.query(Conversation.channel, func.count(Conversation.id).label("count"))
        .filter(Conversation.created_at >= start_date)
        .group_by(Conversation.channel)
        .all()
    )
    channel_distribution = [{"channel": channel, "count": count} for channel, count in channel_counts]

    # ========== NEW EXTENDED DATA ==========
    
    # System Health: AI engine status (always running for rule-based)
    # System Health: Fallback trigger rate (unknown intents)
    unknown_intent_count = db.query(func.count(Conversation.id)).filter(
        and_(Conversation.intent == "unknown", Conversation.created_at >= start_date)
    ).scalar() or 0
    fallback_rate = (unknown_intent_count / total_conversations * 100) if total_conversations > 0 else 0

    # System Health: Rule coverage (intents with responses vs missing)
    all_intents = db.query(Conversation.intent).filter(
        Conversation.created_at >= start_date
    ).distinct().all()
    covered_intents = [intent[0] for intent in all_intents if intent[0] and intent[0] != "unknown"]
    rule_coverage = len(covered_intents) / max(len(all_intents), 1) * 100 if all_intents else 100

    # System Health: Channel connectivity (active channels)
    active_channels = db.query(ChannelIntegration.channel).filter(
        ChannelIntegration.is_active == True
    ).distinct().all()
    channel_connectivity = len(active_channels)

    # Channel Performance Intelligence
    channel_performance = []
    for channel, count in channel_counts:
        channel_leads = db.query(func.count(Lead.id)).filter(
            and_(Lead.channel == channel, Lead.created_at >= start_date)
        ).scalar() or 0
        lead_rate = (channel_leads / count * 100) if count > 0 else 0
        
        # AI resolution rate (conversations that didn't escalate to human)
        # For now, assume all are AI-resolved (no human handoff tracking yet)
        ai_resolution_rate = 95.0  # Placeholder - can be enhanced later
        
        # Peak activity (hour with most messages)
        hour_counts = (
            db.query(func.extract('hour', Conversation.created_at).label("hour"), 
                    func.count(Conversation.id).label("count"))
            .filter(and_(Conversation.channel == channel, Conversation.created_at >= start_date))
            .group_by(func.extract('hour', Conversation.created_at))
            .order_by(func.count(Conversation.id).desc())
            .first()
        )
        peak_hour = int(hour_counts[0]) if hour_counts else None
        
        channel_performance.append({
            "channel": channel,
            "message_volume": count,
            "lead_capture_rate": round(lead_rate, 1),
            "ai_resolution_rate": round(ai_resolution_rate, 1),
            "peak_activity_hour": peak_hour,
        })

    # Intent Quality & Coverage
    intent_quality = []
    for intent, count in intent_counts:
        # Leads generated by this intent
        intent_leads = db.query(func.count(Lead.id)).filter(
            and_(Lead.source_intent == intent, Lead.created_at >= start_date)
        ).scalar() or 0
        
        # Fallback rate for this intent (if unknown)
        is_fallback = (intent == "unknown")
        
        intent_quality.append({
            "intent": intent,
            "count": count,
            "leads_generated": intent_leads,
            "is_fallback": is_fallback,
        })
    
    # Top performing intents (by lead generation)
    top_intents_by_leads = sorted(intent_quality, key=lambda x: x["leads_generated"], reverse=True)[:3]
    
    # Intents causing fallbacks
    fallback_intents = [iq for iq in intent_quality if iq["is_fallback"]]

    # Conversation Flow Funnel
    total_incoming = total_conversations
    ai_responses = total_conversations  # All conversations have AI responses
    # User engagement (conversations with multiple messages - simplified)
    engaged_conversations = db.query(func.count(func.distinct(Conversation.user_id))).filter(
        Conversation.created_at >= start_date
    ).scalar() or 0
    leads_captured = total_leads
    # Human handoff (placeholder - no tracking yet)
    human_handoffs = 0

    # Smart Alerts & Recommendations
    alerts = []
    if fallback_rate > 15:
        alerts.append({
            "type": "warning",
            "priority": "high",
            "title": "High Fallback Rate",
            "message": f"{round(fallback_rate, 1)}% of conversations are falling back to default responses. Consider adding intent rules.",
        })
    if rule_coverage < 80:
        alerts.append({
            "type": "info",
            "priority": "medium",
            "title": "Rule Coverage Gap",
            "message": f"Only {round(rule_coverage, 1)}% of detected intents have custom responses.",
        })
    # Channel underperforming
    if channel_performance:
        min_lead_rate = min(cp["lead_capture_rate"] for cp in channel_performance)
        underperforming = [cp for cp in channel_performance if cp["lead_capture_rate"] == min_lead_rate and min_lead_rate < 5]
        if underperforming:
            alerts.append({
                "type": "info",
                "priority": "medium",
                "title": "Channel Performance",
                "message": f"{underperforming[0]['channel']} has low lead capture rate ({min_lead_rate}%).",
            })

    # Recent Activity Timeline
    recent_leads = db.query(Lead).filter(
        Lead.created_at >= start_date
    ).order_by(Lead.created_at.desc()).limit(5).all()
    
    recent_events = []
    for lead in recent_leads:
        recent_events.append({
            "type": "lead",
            "title": f"New lead from {lead.channel}",
            "description": f"{lead.name or 'Anonymous'} - {lead.source_intent or 'unknown intent'}",
            "timestamp": lead.created_at.isoformat(),
        })
    
    # Add intent gap events (unknown intents)
    if unknown_intent_count > 0:
        recent_events.append({
            "type": "intent_gap",
            "title": "Intent Gap Detected",
            "description": f"{unknown_intent_count} conversations with unknown intent in the last {days} days",
            "timestamp": datetime.utcnow().isoformat(),
        })

    # Lead Snapshot Summary
    leads_today = db.query(func.count(Lead.id)).filter(
        func.date(Lead.created_at) == func.date(datetime.utcnow())
    ).scalar() or 0
    
    leads_this_week = db.query(func.count(Lead.id)).filter(
        Lead.created_at >= datetime.utcnow() - timedelta(days=7)
    ).scalar() or 0
    
    # Best performing channel for leads
    best_channel_leads = (
        db.query(Lead.channel, func.count(Lead.id).label("count"))
        .filter(Lead.created_at >= start_date)
        .group_by(Lead.channel)
        .order_by(func.count(Lead.id).desc())
        .first()
    )
    best_channel = best_channel_leads[0] if best_channel_leads else None
    
    # Top lead-generating intent
    top_lead_intent = (
        db.query(Lead.source_intent, func.count(Lead.id).label("count"))
        .filter(and_(Lead.created_at >= start_date, Lead.source_intent.isnot(None)))
        .group_by(Lead.source_intent)
        .order_by(func.count(Lead.id).desc())
        .first()
    )
    top_lead_intent_name = top_lead_intent[0] if top_lead_intent else None

    # Time-Based Performance Insights
    # Best performing hour
    hour_performance = (
        db.query(func.extract('hour', Conversation.created_at).label("hour"),
                func.count(Conversation.id).label("count"))
        .filter(Conversation.created_at >= start_date)
        .group_by(func.extract('hour', Conversation.created_at))
        .order_by(func.count(Conversation.id).desc())
        .first()
    )
    best_hour = int(hour_performance[0]) if hour_performance else None
    
    # Best performing day of week
    day_performance = (
        db.query(func.extract('dow', Conversation.created_at).label("day"),
                func.count(Conversation.id).label("count"))
        .filter(Conversation.created_at >= start_date)
        .group_by(func.extract('dow', Conversation.created_at))
        .order_by(func.count(Conversation.id).desc())
        .first()
    )
    best_day = int(day_performance[0]) if day_performance else None
    day_names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    best_day_name = day_names[best_day] if best_day is not None else None

    return {
        # Existing data
        "total_conversations": total_conversations,
        "active_chats": active_chats,
        "leads_captured": total_leads,
        "most_common_intents": most_common_intents,
        "channel_distribution": channel_distribution,
        "period_days": days,
        # New extended data
        "system_health": {
            "ai_engine_status": "running",
            "rule_coverage_health": round(rule_coverage, 1),
            "fallback_trigger_rate": round(fallback_rate, 1),
            "channel_connectivity": channel_connectivity,
        },
        "channel_performance": channel_performance,
        "intent_quality": {
            "top_performing": top_intents_by_leads,
            "lead_generating": [iq for iq in intent_quality if iq["leads_generated"] > 0],
            "causing_fallbacks": fallback_intents,
        },
        "conversation_flow": {
            "incoming": total_incoming,
            "ai_responses": ai_responses,
            "user_engagement": engaged_conversations,
            "leads_captured": leads_captured,
            "human_handoffs": human_handoffs,
        },
        "alerts": alerts[:5],  # Limit to 5 most important
        "recent_activity": recent_events[:10],  # Limit to 10 most recent
        "lead_snapshot": {
            "leads_today": leads_today,
            "leads_this_week": leads_this_week,
            "best_channel": best_channel,
            "top_lead_intent": top_lead_intent_name,
        },
        "time_insights": {
            "best_hour": best_hour,
            "best_day": best_day_name,
        },
    }


@router.get("/conversations")
async def get_conversations(
    page: int = Query(1, ge=1),
    limit: int = Query(20, ge=1, le=100),
    channel: Optional[str] = None,
    intent: Optional[str] = None,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Get paginated conversations list."""
    query = db.query(Conversation)

    # Apply filters
    if channel:
        query = query.filter(Conversation.channel == channel)
    if intent:
        query = query.filter(Conversation.intent == intent)

    # Get total count
    total = query.count()

    # Apply pagination
    offset = (page - 1) * limit
    conversations = query.order_by(Conversation.created_at.desc()).offset(offset).limit(limit).all()

    return {
        "conversations": [
            {
                "id": conv.id,
                "user_id": conv.user_id,
                "channel": conv.channel,
                "user_message": conv.user_message,
                "bot_reply": conv.bot_reply,
                "intent": conv.intent,
                "created_at": conv.created_at.isoformat(),
            }
            for conv in conversations
        ],
        "total": total,
        "page": page,
        "limit": limit,
        "total_pages": (total + limit - 1) // limit,
    }


@router.get("/analytics/intents")
async def get_intent_analytics(
    days: int = Query(30, ge=1, le=365),
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Get intent analytics over time."""
    start_date = datetime.utcnow() - timedelta(days=days)

    # Intent frequency
    intent_data = (
        db.query(Conversation.intent, func.count(Conversation.id).label("count"))
        .filter(Conversation.created_at >= start_date)
        .group_by(Conversation.intent)
        .order_by(func.count(Conversation.id).desc())
        .all()
    )

    return {
        "intents": [{"intent": intent, "count": count} for intent, count in intent_data],
        "period_days": days,
    }


@router.get("/analytics/channels")
async def get_channel_analytics(
    days: int = Query(30, ge=1, le=365),
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Get channel performance analytics."""
    start_date = datetime.utcnow() - timedelta(days=days)

    channel_data = (
        db.query(
            Conversation.channel,
            func.count(Conversation.id).label("total"),
            func.count(func.distinct(Conversation.user_id)).label("unique_users"),
        )
        .filter(Conversation.created_at >= start_date)
        .group_by(Conversation.channel)
        .all()
    )

    return {
        "channels": [
            {"channel": channel, "total_conversations": total, "unique_users": unique_users}
            for channel, total, unique_users in channel_data
        ],
        "period_days": days,
    }


@router.get("/analytics/timeline")
async def get_timeline_analytics(
    days: int = Query(7, ge=1, le=90),
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Get conversation timeline data."""
    start_date = datetime.utcnow() - timedelta(days=days)

    # Group by day
    timeline_data = (
        db.query(
            func.date(Conversation.created_at).label("date"),
            func.count(Conversation.id).label("count"),
        )
        .filter(Conversation.created_at >= start_date)
        .group_by(func.date(Conversation.created_at))
        .order_by(func.date(Conversation.created_at))
        .all()
    )

    return {
        "timeline": [{"date": str(date), "count": count} for date, count in timeline_data],
        "period_days": days,
    }


@router.get("/leads")
async def get_leads(
    page: int = Query(1, ge=1),
    limit: int = Query(20, ge=1, le=100),
    status: Optional[str] = None,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Get paginated leads list."""
    query = db.query(Lead)

    if status:
        query = query.filter(Lead.status == status)

    total = query.count()
    offset = (page - 1) * limit
    leads = query.order_by(Lead.created_at.desc()).offset(offset).limit(limit).all()

    return {
        "leads": [
            {
                "id": lead.id,
                "user_id": lead.user_id,
                "channel": lead.channel,
                "name": lead.name,
                "email": lead.email,
                "phone": lead.phone,
                "status": lead.status,
                "source_intent": lead.source_intent,
                "created_at": lead.created_at.isoformat(),
            }
            for lead in leads
        ],
        "total": total,
        "page": page,
        "limit": limit,
        "total_pages": (total + limit - 1) // limit,
    }

